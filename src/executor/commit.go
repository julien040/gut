package executor

import (
	"bufio"
	"errors"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/format/gitignore"
	"github.com/go-git/go-git/v5/plumbing/object"
)

type CommitResult struct {
	Hash         string
	FilesAdded   int
	FilesUpdated int
	FilesDeleted int
}

// Add all files to the staging area
//
// If git is installed, use git add . to add all files. If not, use go-git
func AddAll(path string) error {
	// Check if git is installed
	isGitInstalled := IsGitInstalled()
	if isGitInstalled {
		// Run git add . to add all files using git
		// This is a workaround for the fact that go-git does not support .gitignore
		err := GitAddAll()

		return err
	} else {
		repo, err := OpenRepo(path)
		if err != nil {
			return err
		}
		w, err := repo.Worktree()
		if err != nil {
			return err
		}
		// Replace the .gitignore file with the one in the repo
		replaceGitIgnore(w, filepath.Join(path, ".gitignore"))

		// Add all files
		err = w.AddWithOptions(&git.AddOptions{
			All: true,
		})
		return err
	}
}

// Remove all files from the staging area
func RemoveAll(path string) error {
	// Check if git is installed
	isGitInstalled := IsGitInstalled()
	if isGitInstalled {
		// Run git add . to add all files using git
		// This is a workaround for the fact that go-git does not support .gitignore
		err := GitRemoveAll()

		return err
	} else {
		repo, err := OpenRepo(path)
		if err != nil {
			return err
		}
		w, err := repo.Worktree()
		if err != nil {
			return err
		}
		// Replace the .gitignore file with the one in the repo
		replaceGitIgnore(w, filepath.Join(path, ".gitignore"))

		// Remove all files
		err = w.Reset(&git.ResetOptions{
			Mode: git.MixedReset,
		})

		return err
	}
}

// Add a file to the staging area
func AddIndexPath(w git.Worktree, path string) error {
	// Add the file
	_, err := w.Add(path)

	return err
}

// Commit the changes
// If no files are passed as arguments, all files will be committed
// Otherwise, only the files passed as arguments will be committed
func Commit(path string, message string, file []string) (CommitResult, error) {
	repo, err := OpenRepo(path)
	if err != nil {
		return CommitResult{}, err
	}
	w, err := repo.Worktree()
	if err != nil {
		return CommitResult{}, err
	}

	// If no files are passed as arguments, add all files
	if len(file) == 0 {
		// Add all files
		err = AddAll(path)
		if err != nil {
			return CommitResult{}, err
		}
	} else {
		// Add only the files passed as arguments
		RemoveAll(path)
		replaceGitIgnore(w, filepath.Join(path, ".gitignore"))

		for _, v := range file {
			// Add the file
			err = AddIndexPath(*w, v)
			if err != nil {
				return CommitResult{}, err
			}
		}
	}

	status, err := w.Status()
	if err != nil {
		return CommitResult{}, err
	}
	fileAdded := 0
	fileUpdated := 0
	fileDeleted := 0
	for _, v := range status {
		if v.Staging == git.Added {
			fileAdded++
		}
		if v.Staging == git.Deleted {
			fileDeleted++
		}
		if v.Staging == git.Modified {
			fileUpdated++
		}
	}
	hash, err := w.Commit(message, &git.CommitOptions{
		// All: true,
	})
	if err != nil {
		return CommitResult{}, err
	}
	return CommitResult{
		Hash:         hash.String(),
		FilesAdded:   fileAdded,
		FilesUpdated: fileUpdated,
		FilesDeleted: fileDeleted,
	}, nil
}

// Load the .gitignore file, and add to the "exclude" section of the worktree
//
// This is a workaround for the fact that go-git does not support .gitignore
func replaceGitIgnore(wk *git.Worktree, path string) {
	f, _ := os.Open(path)
	defer f.Close()

	// Read the file
	scanner := bufio.NewScanner(f)
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		line := scanner.Text()
		// Add the line to the exclude list
		wk.Excludes = append(wk.Excludes, gitignore.ParsePattern(line, nil))
	}

}

/* CODE GENERATED BY COPILOT
 * SHOULD BE TESTED BEFORE USE
 */

// List commit for the current branch
func ListCommit(path string) ([]object.Commit, error) {
	repo, err := OpenRepo(path)
	if err != nil {
		return nil, err
	}
	// Get the branch
	ref, err := repo.Head()
	if err != nil {
		return nil, err
	}
	// Get the commit history
	commitIter, err := repo.Log(&git.LogOptions{From: ref.Hash()})
	if err != nil {
		return nil, err
	}
	// Get the commits
	commits := []object.Commit{}
	err = commitIter.ForEach(func(c *object.Commit) error {
		commits = append(commits, *c)
		return nil
	})
	if err != nil {
		return nil, err
	}
	// Sort the commits by date
	sort.Slice(commits, func(i, j int) bool {
		return commits[i].Author.When.After(commits[j].Author.When)
	})
	return commits, nil
}

/* CODE GENERATED BY COPILOT
 * SHOULD BE TESTED BEFORE USE
 */

// List all commits for the repo even if not on the current branch
func ListAllCommits(path string) ([]object.Commit, error) {
	repo, err := OpenRepo(path)
	if err != nil {
		return nil, err
	}
	// Get the commit history
	commitIter, err := repo.Log(&git.LogOptions{})
	if err != nil {
		return nil, err
	}
	// Get the commits
	commits := []object.Commit{}
	err = commitIter.ForEach(func(c *object.Commit) error {
		commits = append(commits, *c)
		return nil
	})
	if err != nil {
		return nil, err
	}
	// Sort the commits by date
	sort.Slice(commits, func(i, j int) bool {
		return commits[i].Author.When.After(commits[j].Author.When)
	})
	return commits, nil
}

func GetCommitByHash(path string, hash string) (object.Commit, error) {
	if len(hash) < 6 {
		return object.Commit{}, errors.New("hash must be at least 6 characters")
	}
	// List all commits
	commits, err := ListAllCommits(path)
	if err != nil {
		return object.Commit{}, err
	}
	// Find the commit
	for _, c := range commits {
		if strings.HasPrefix(c.Hash.String(), hash) {
			return c, nil
		}
	}
	return object.Commit{}, errors.New("commit not found")
}

func GetHeadHash(path string) (string, error) {
	repo, err := OpenRepo(path)
	if err != nil {
		return "", err
	}
	// Get the branch
	ref, err := repo.Head()
	if err != nil {
		return "", err
	}
	return ref.Hash().String(), nil
}

func CheckoutCommit(path string, commitHash string) error {
	repo, err := OpenRepo(path)
	if err != nil {
		return err
	}
	// Get the commit
	commit, err := repo.CommitObject(plumbing.NewHash(commitHash))
	if err != nil {
		return err
	}
	// Checkout the commit
	w, err := repo.Worktree()
	if err != nil {
		return err
	}
	err = w.Checkout(&git.CheckoutOptions{
		Hash: commit.Hash,
	})
	if err != nil {
		return err
	}
	return nil
}
